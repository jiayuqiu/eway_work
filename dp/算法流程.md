# 三种Douglas-Pecuker的压缩思路
三种压缩算法，都以经典D-P算法为基础。

## 1. 经典D-P算法

此处放入经典D-P算法思路图
### 算法思路：
将首点和尾点分别作为初始锚点和初始漂浮点，并将其连成的直线称为基线。依次计算中间各点到基线的垂直距离，并找出最大距离对应的点。若最大距离小于设定的阈值，则用基线代替原始曲线。若最大距离大于设定的阈值，则将最大距离对应的点作为分裂点，并将该分裂点作为前向点集的漂浮点和后向点集的锚点。依次递归选取分裂点和分段，直到每一个子集中都不再出现新的分裂点。
---
## 2. 动态D-P算法

此处放入动态D-P算法与经典D-P算法的对比
### 算法思路：
在经典D-P算法的基础上，加上了时间特征，可以尽可能保留速度信息。
---
## 3. 快速D-P算法

此处放入两张流程图
### 算法思路：
1. 将首点和尾点分别作为初始锚点和初始漂浮点，起点S、终点E，并将其连成的直线称为基线SE，依次将中间点两两相连形成向量。
2. 将点I、点I-1、点I+1、点S别投影到与向量SE且经过点S的平面上，得到点I'、点I-1'、点I+1'、点S'。
3. 判断向量S'I'分别与向量I'I-1'向量I'I+1'形成的夹角。若夹角都为钝角，那么点I为状态驻点。
4. 分别循环中间点，找到所有的状态驻点并求出状态驻点到基线SE的垂直距离，找到最大值maxDst与其对应的索引maxDstIndex并记录。
5. 判断maxDst是否大于距离阈值，若大于距离阈值，记录maxDstIndex所在数据并按该索引分两段递归调用压缩算法；若小于距离阈值，仅保留首尾两点，程序结束。

# 三种Douglas-Pecuker的程序说明

## 调用压缩算法的程序段

**根据速度限差进行分段**
```Python
def speed_point(each_data):
    pythonCode...
```
输入参数：each_data -- 单船AIS数据，类型：list
返回值：list_x -- 索引列表，类型：list
<br>

**调用压缩算法函数**
```python
def compress_QDP(input_data):
    pythonCode...
```
输入参数：input_data -- groupedData被分组后的数据，可以是grouped RDD 或者 grouped data frame
返回值：compress_str -- 压缩后的AIS数据

## 经典D-P算法（雷高魁编写）
DP.py

**经典D-P算法程序段**
输入参数：grouped_datas -- 单船一段AIS数据；outdata -- 暂存输出数据
返回值：compress_str -- 压缩后的AIS数据
```Python
def classic_dp(grouped_datas, outdata):
    pythonCode...
```

## 动态D-P算法（雷高魁编写）
DDP.py

**动态D-P算法程序段**
输入参数：onestage -- 单船一段AIS数据；outdata -- 暂存输出数据
返回值：compress_str -- 压缩后的AIS数据
```python
def dongtai_dp(onestage,outdata):
    pythonCode...
```

## 快速D-P算法
compress.py
该文件中的compress类，用于存放所有压缩算法的函数

**坐标投影**
将三维坐标点投影到平面M<br>
输入参数：oneStage -- 一条船一段AIS数据；col0 : mmsi, col1 : time, col2 : lon, col3 : lat；
vectorSE -- 首尾两点形成的向量
返回值：prejectionPointsList -- 对应坐标投影后的坐标

**获得分断点**
通过投影点的集合，找到状态驻点并找到距离最远的点，作为分段点<br>
输入参数：projectionPoints -- 分段点的集合
返回值：maxDst -- 距离最大值； maxDstIndex -- 距离最大值对应的索引
```python
def __getBlockPoint(self, projectionPoints):
    pythonCode...
```

**快速D-P算法程序段**
输入参数：onestage -- 单船一段AIS数据；outdata -- 暂存输出数据
```python
def quickDPOPT(self, oneStage, outData):
    pythonCode...
```
